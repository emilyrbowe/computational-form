/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/tracery-grammar@2.7.4/tracery.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var tracery = function() {
  var t = function(t, e, s) {
    this.errors = [], void 0 === s.raw && (this.errors.push(
        "Empty input for node"), s.raw = ""), t instanceof tracery.Grammar ?
      (this.grammar = t, this.parent = null, this.depth = 0, this.childIndex =
        0) : (this.grammar = t.grammar, this.parent = t, this.depth = t.depth +
        1, this.childIndex = e), this.raw = s.raw, this.type = s.type, this
      .isExpanded = !1, this.grammar || this.errors.push(
        "No grammar specified for this node " + this)
  };

  function e(t, e) {
    this.node = t;
    var s = e.split(":");
    this.target = s[0], 1 === s.length ? this.type = 2 : (this.rule = s[1],
      "POP" === this.rule ? this.type = 1 : this.type = 0)
  }

  function s(t, e) {
    this.raw = e, this.grammar = t, this.falloff = 1, Array.isArray(e) ? this
      .defaultRules = e : ("string" == typeof e || e instanceof String) && (
        this.defaultRules = [e])
  }
  t.prototype.toString = function() {
    return "Node('" + this.raw + "' " + this.type + " d:" + this.depth +
      ")"
  }, t.prototype.expandChildren = function(e, s) {
    if (this.children = [], this.finishedText = "", this.childRule = e,
      void 0 !== this.childRule) {
      var i = tracery.parse(e);
      i.errors.length > 0 && (this.errors = this.errors.concat(i.errors));
      for (var r = 0; r < i.length; r++) this.children[r] = new t(this, r,
          i[r]), s || this.children[r].expand(s), this.finishedText += this
        .children[r].finishedText
    } else this.errors.push("No child rule provided, can't expand children")
  }, t.prototype.expand = function(t) {
    if (!this.isExpanded) switch (this.isExpanded = !0, this.expansionErrors = [],
      this.type) {
      case -1:
        this.expandChildren(this.raw, t);
        break;
      case 0:
        this.finishedText = this.raw;
        break;
      case 1:
        this.preactions = [], this.postactions = [];
        var s = tracery.parseTag(this.raw);
        this.symbol = s.symbol, this.modifiers = s.modifiers;
        for (var i = 0; i < s.preactions.length; i++) this.preactions[i] =
          new e(this, s.preactions[i].raw);
        for (i = 0; i < s.postactions.length; i++);
        for (i = 0; i < this.preactions.length; i++) 0 === this.preactions[
          i].type && this.postactions.push(this.preactions[i].createUndo());
        for (i = 0; i < this.preactions.length; i++) this.preactions[i].activate();
        this.finishedText = this.raw;
        var r = this.grammar.selectRule(this.symbol, this, this.errors);
        this.expandChildren(r, t);
        for (i = 0; i < this.modifiers.length; i++) {
          var a = this.modifiers[i],
            n = [];
          if (a.indexOf("(") > 0) {
            var h = /\(([^)]+)\)/.exec(this.modifiers[i]);
            if (!h || h.length < 2);
            else {
              n = h[1].split(",");
              a = this.modifiers[i].substring(0, a.indexOf("("))
            }
          }
          var o = this.grammar.modifiers[a];
          o ? this.finishedText = o(this.finishedText, n) : (this.errors.push(
              "Missing modifier " + a), this.finishedText += "((." + a +
            "))")
        }
        for (i = 0; i < this.postactions.length; i++) this.postactions[i]
          .activate();
        break;
      case 2:
        this.action = new e(this, this.raw), this.action.activate(), this
          .finishedText = ""
    }
  }, t.prototype.clearEscapeChars = function() {
    this.finishedText = this.finishedText.replace(/\\\\/g,
      "DOUBLEBACKSLASH").replace(/\\/g, "").replace(/DOUBLEBACKSLASH/g,
      "\\")
  }, e.prototype.createUndo = function() {
    return 0 === this.type ? new e(this.node, this.target + ":POP") : null
  }, e.prototype.activate = function() {
    var e = this.node.grammar;
    switch (this.type) {
      case 0:
        this.ruleSections = this.rule.split(","), this.finishedRules = [],
          this.ruleNodes = [];
        for (var s = 0; s < this.ruleSections.length; s++) {
          var i = new t(e, 0, {
            type: -1,
            raw: this.ruleSections[s]
          });
          i.expand(), this.finishedRules.push(i.finishedText)
        }
        e.pushRules(this.target, this.finishedRules, this);
        break;
      case 1:
        e.popRules(this.target);
        break;
      case 2:
        e.flatten(this.target, !0)
    }
  }, e.prototype.toText = function() {
    switch (this.type) {
      case 0:
        return this.target + ":" + this.rule;
      case 1:
        return this.target + ":POP";
      case 2:
        return "((some function))";
      default:
        return "((Unknown Action))"
    }
  }, s.prototype.selectRule = function(t) {
    if (this.conditionalRule) {
      var e = this.grammar.expand(this.conditionalRule, !0);
      if (this.conditionalValues[e])
        if (null != (i = this.conditionalValues[e].selectRule(t))) return i
    }
    if (this.ranking)
      for (var s = 0; s < this.ranking.length; s++) {
        var i;
        if (null != (i = this.ranking.selectRule())) return i
      }
    if (void 0 !== this.defaultRules) {
      var r = 0,
        a = this.distribution;
      switch (a || (a = this.grammar.distribution), a) {
        case "shuffle":
          this.shuffledDeck && 0 !== this.shuffledDeck.length || (this.shuffledDeck =
              function(t, e) {
                var s, i, r = t.length;
                for (; 0 !== r;) i = Math.floor(Math.random() * r), s = t[r -=
                  1], t[r] = t[i], t[i] = s;
                return t
              }(Array.apply(null, {
                length: this.defaultRules.length
              }).map(Number.call, Number), this.falloff)), r = this.shuffledDeck
            .pop();
          break;
        case "weighted":
          t.push("Weighted distribution not yet implemented");
          break;
        case "falloff":
          t.push("Falloff distribution not yet implemented");
          break;
        default:
          r = Math.floor(Math.pow(Math.random(), this.falloff) * this.defaultRules
            .length)
      }
      return this.defaultUses || (this.defaultUses = []), this.defaultUses[
        r] = ++this.defaultUses[r] || 1, this.defaultRules[r]
    }
    return t.push("No default rules defined for " + this), null
  }, s.prototype.clearState = function() {
    this.defaultUses && (this.defaultUses = [])
  };
  var i = function(t, e, i) {
    this.key = e, this.grammar = t, this.rawRules = i, this.baseRules = new s(
      this.grammar, i), this.clearState()
  };
  i.prototype.clearState = function() {
    this.stack = [this.baseRules], this.uses = [], this.baseRules.clearState()
  }, i.prototype.pushRules = function(t) {
    var e = new s(this.grammar, t);
    this.stack.push(e)
  }, i.prototype.popRules = function() {
    this.stack.pop()
  }, i.prototype.selectRule = function(t, e) {
    return this.uses.push({
      node: t
    }), 0 === this.stack.length ? (e.push("The rule stack for '" + this.key +
      "' is empty, too many pops?"), "((" + this.key + "))") : this.stack[
      this.stack.length - 1].selectRule()
  }, i.prototype.getActiveRules = function() {
    return 0 === this.stack.length ? null : this.stack[this.stack.length -
      1].selectRule()
  }, i.prototype.rulesToJSON = function() {
    return JSON.stringify(this.rawRules)
  };
  var r = function(t, e) {
    this.modifiers = {}, this.loadFromRawObj(t)
  };

  function a(t) {
    var e = t.toLowerCase();
    return "a" === e || "e" === e || "i" === e || "o" === e || "u" === e
  }
  r.prototype.clearState = function() {
    for (var t = Object.keys(this.symbols), e = 0; e < t.length; e++) this.symbols[
      t[e]].clearState()
  }, r.prototype.addModifiers = function(t) {
    for (var e in t) t.hasOwnProperty(e) && (this.modifiers[e] = t[e])
  }, r.prototype.loadFromRawObj = function(t) {
    if (this.raw = t, this.symbols = {}, this.subgrammars = [], this.raw)
      for (var e in this.raw) this.raw.hasOwnProperty(e) && (this.symbols[e] =
        new i(this, e, this.raw[e]))
  }, r.prototype.createRoot = function(e) {
    return new t(this, 0, {
      type: -1,
      raw: e
    })
  }, r.prototype.expand = function(t, e) {
    var s = this.createRoot(t);
    return s.expand(), e || s.clearEscapeChars(), s
  }, r.prototype.flatten = function(t, e) {
    return this.expand(t, e).finishedText
  }, r.prototype.toJSON = function() {
    for (var t = Object.keys(this.symbols), e = [], s = 0; s < t.length; s++) {
      var i = t[s];
      e.push(' "' + i + '" : ' + this.symbols[i].rulesToJSON())
    }
    return "{\n" + e.join(",\n") + "\n}"
  }, r.prototype.pushRules = function(t, e, s) {
    void 0 === this.symbols[t] ? (this.symbols[t] = new i(this, t, e), s &&
      (this.symbols[t].isDynamic = !0)) : this.symbols[t].pushRules(e)
  }, r.prototype.popRules = function(t) {
    this.symbols[t] || this.errors.push("Can't pop: no symbol for key " + t),
      this.symbols[t].popRules()
  }, r.prototype.selectRule = function(t, e, s) {
    if (this.symbols[t]) return this.symbols[t].selectRule(e, s);
    for (var i = 0; i < this.subgrammars.length; i++)
      if (this.subgrammars[i].symbols[t]) return this.subgrammars[i].symbols[
        t].selectRule();
    return s.push("No symbol for '" + t + "'"), "((" + t + "))"
  };
  var n = {
    replace: function(t, e) {
      return t.replace(new RegExp(e[0].replace(
        /([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"), "g"), e[1])
    },
    capitalizeAll: function(t) {
      for (var e, s = "", i = !0, r = 0; r < t.length; r++)(e = t.charAt(
          r)) >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <=
        "9" ? i ? (s += t.charAt(r).toUpperCase(), i = !1) : s += t.charAt(
          r) : (i = !0, s += t.charAt(r));
      return s
    },
    capitalize: function(t) {
      return t.charAt(0).toUpperCase() + t.substring(1)
    },
    a: function(t) {
      if (t.length > 0) {
        if ("u" === t.charAt(0).toLowerCase() && t.length > 2 && "i" ===
          t.charAt(2).toLowerCase()) return "a " + t;
        if (a(t.charAt(0))) return "an " + t
      }
      return "a " + t
    },
    firstS: function(t) {
      console.log(t);
      var e = t.split(" "),
        s = n.s(e[0]) + " " + e.slice(1).join(" ");
      return console.log(s), s
    },
    s: function(t) {
      switch (t.charAt(t.length - 1)) {
        case "s":
        case "h":
        case "x":
          return t + "es";
        case "y":
          return a(t.charAt(t.length - 2)) ? t + "s" : t.substring(0, t.length -
            1) + "ies";
        default:
          return t + "s"
      }
    },
    ed: function(t) {
      switch (t.charAt(t.length - 1)) {
        case "s":
          return t + "ed";
        case "e":
          return t + "d";
        case "h":
        case "x":
          return t + "ed";
        case "y":
          return a(t.charAt(t.length - 2)) ? t + "d" : t.substring(0, t.length -
            1) + "ied";
        default:
          return t + "ed"
      }
    }
  };
  return (tracery = {
      createGrammar: function(t) {
        return new r(t)
      },
      parseTag: function(t) {
        for (var e = {
            symbol: void 0,
            preactions: [],
            postactions: [],
            modifiers: []
          }, s = tracery.parse(t), i = void 0, r = 0; r < s.length; r++)
          if (0 === s[r].type) {
            if (void 0 !== i) throw "multiple main sections in " + t;
            i = s[r].raw
          } else e.preactions.push(s[r]);
        if (void 0 === i);
        else {
          var a = i.split(".");
          e.symbol = a[0], e.modifiers = a.slice(1)
        }
        return e
      },
      parse: function(t) {
        var e = 0,
          s = !1,
          i = [],
          r = !1,
          a = [],
          n = 0,
          h = "",
          o = void 0;
        if (null === t) return (i = []).errors = a, i;

        function l(e, s, r) {
          var n;
          s - e < 1 && (1 === r && a.push(e + ": empty tag"), 2 === r &&
              a.push(e + ": empty action")), n = void 0 !== o ? h + "\\" +
            t.substring(o + 1, s) : t.substring(e, s), i.push({
              type: r,
              raw: n
            }), o = void 0, h = ""
        }
        for (var u = 0; u < t.length; u++) {
          if (r) r = !1;
          else switch (t.charAt(u)) {
            case "[":
              0 !== e || s || (n < u && l(n, u, 0), n = u + 1), e++;
              break;
            case "]":
              0 !== --e || s || (l(n, u, 2), n = u + 1);
              break;
            case "#":
              0 === e && (s ? (l(n, u, 1), n = u + 1) : (n < u && l(n,
                u, 0), n = u + 1), s = !s);
              break;
            case "\\":
              r = !0, h += t.substring(n, u), n = u + 1, o = u
          }
        }
        return n < t.length && l(n, t.length, 0), s && a.push(
          "Unclosed tag"), e > 0 && a.push("Too many ["), e < 0 && a.push(
          "Too many ]"), (i = i.filter(function(t) {
          return 0 !== t.type || 0 !== t.raw.length
        })).errors = a, i
      }
    }).baseEngModifiers = n, tracery.TraceryNode = t, tracery.Grammar = r,
    tracery.Symbol = i, tracery.RuleSet = s, tracery
}();
module.exports = tracery;
//# sourceMappingURL=/sm/ea319ca60360ec297285ca7ac103751c4b26f7549d8d4b3607a032d5e9c96c08.map
